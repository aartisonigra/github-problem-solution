Magnetic Row Reversal
Problem Statement
You are given a 1-indexed array A of N integers, where each element represents the magnetic polarity of a cell:

1 → positive pole

-1 → negative pole

0 → neutral (non-magnetic)

You can perform the following operation any number of times:


Select a contiguous subarray of length exactly K (1 ≤ K ≤ N), and reverse the magnetic polarity of each cell in it:

1 becomes -1

-1 becomes 1

0 remains 0

Your goal is to make the entire array non-negative (i.e., all elements should be either 0 or 1) in the minimum number of operations.
If it is not possible, output -1.

Input Format
First line contains two integers N and K

Second line contains N space-separated integers A[i] ∈ {-1, 0, 1}

Output Format
Print the minimum number of operations required to make the array non-negative, or -1 if it is impossible.

Constraints
1 ≤ N ≤ 10^4

1 ≤ K ≤ N

A[i] ∈ {-1, 0, 1}

Sample Testcase 0
Testcase Input
6 2
-1 0 -1 1 -1 1
Testcase Output
3
Explanation
We must flip segments of size 2 to convert all -1s to 1. Only -1s must be flipped; 0s are neutral.


Flip at index 0: [-1, 0] → [1, 0]


Flip at index 2: [-1, 1] → [1, -1]


Flip at index 3: [-1, -1] → [1, 1]


Final array: [1, 0, 1, 1, 1, 1]
Flips needed: 3

Sample Testcase 1
Testcase Input
5 3
1 -1 0 -1 1
Testcase Output
1
Explanation
Flip of size 3 can flip only one segment.
Flip at index 1: [-1, 0, -1] → [1, 0, 1]


Final array: [1, 1, 0, 1, 1]
All -1s removed.
Flips needed: 1


  SOLUTIONS:

import java.util.Scanner;

public class Main {

    public static int minOperationsToNonNegative(int n, int k, int[] A) {
        int flips = 0;
        int[] flipEffect = new int[n]; // tracks whether current index is flipped an odd number of times
        int currentFlips = 0; // how many flips are affecting current index

        for (int i = 0; i < n; i++) {
            // If flipEffect from previous flips ends, subtract it
            if (i >= k) {
                currentFlips -= flipEffect[i - k];
            }

            int val = A[i];
            // If current value is affected by flips, reverse its sign
            if (currentFlips % 2 != 0) {
                if (val == 1) val = -1;
                else if (val == -1) val = 1;
            }

            // If value is negative, we need to flip starting here
            if (val == -1) {
                if (i + k > n) return -1; // cannot flip segment of size k
                flips++;
                currentFlips++;
                flipEffect[i] = 1; // mark flip starting here
            }
        }

        return flips;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] A = new int[n];
        for (int i = 0; i < n; i++) {
            A[i] = sc.nextInt();
        }
        sc.close();

        int result = minOperationsToNonNegative(n, k, A);
        System.out.println(result);
    }
}
