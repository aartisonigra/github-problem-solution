Turtle Colony Rescue Mission
Problem Statement
You are in charge of an island where a rare species of turtle resides. The turtles live in colonies, and their locations are marked on a 2D grid. The grid has three types of cells:

'T' → A turtle colony that must be rescued.

'.' → Walkable land.

'#' → Inaccessible terrain.

You are provided with a starting point (Sx, Sy) — your rescue vehicle’s current position. The rescue vehicle can move up, down, left, or right, but cannot move through #.

However, to reduce environmental disturbance, each turtle colony can only be visited once and must be rescued in a single connected path — you must not return to the base after rescuing one and then go to the next. Your task is to find the minimum total number of steps required to rescue all the turtles in a single traversal path, starting from your vehicle.

If it's not possible to reach and rescue all colonies, return -1.

Input Format
First line contains two integers N and M

Next N lines: A string of length M representing the grid (only contains 'T', '.', and '#').

Last line contains two integers Sx and Sy.

 

Output Format
Print the minimum number of steps to rescue all turtles, or -1 if not possible.

Constraints
1 ≤ N, M ≤ 20

Grid contains at most 10 turtle colonies.

0 ≤ Sx < N, 0 ≤ Sy < M

Sample Testcase 0
Testcase Input
4 5
.T..T
..#.#
#.T..
.#...
0 0
Testcase Output
8
Explanation
Turtle positions:


(0,1), (0,4), (2,2)
Start position: (0,0)


Grid layout:
.T..T
..#.#
#.T..
.#...


Path (minimum steps):


(0,0) → (0,1) [1] → (1,1) [2] → (2,1) [3] → (2,2) [4]


→ (2,3) [5] → (1,3) [6] → (0,3) [7] → (0,4) [8]


All 3 turtles collected in 8 steps.

Sample Testcase 1
Testcase Input
3 3
T#T
.#.
T#T
1 1
Testcase Output
-1
Explanation
Turtle positions: (0,0), (0,2), (2,0), (2,2)
Start: (1,1)


Grid layout:
T # T
. # .
T # T



There’s no path to any of the turtle colonies — they are all isolated by # walls.


Hence, not all turtles can be rescued. Output: -1





  SOLUTIONS:

import java.util.*;

public class Main {
    static final int INF = 1_000_000_000;
    static int[] dx = {1, -1, 0, 0};
    static int[] dy = {0, 0, 1, -1};

    public static int rescueTurtles(char[][] grid, int sx, int sy) {
        int n = grid.length, m = grid[0].length;

        List<int[]> points = new ArrayList<>();
        points.add(new int[]{sx, sy}); // index 0 = start

        // Collect turtle positions
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 'T') {
                    points.add(new int[]{i, j});
                }
            }
        }

        int totalPoints = points.size();
        int K = totalPoints - 1; // number of turtles

        if (K == 0) return 0; // no turtles to rescue

        // Precompute shortest distances between points using BFS
        int[][] dist = new int[totalPoints][totalPoints];
        for (int i = 0; i < totalPoints; i++) {
            Arrays.fill(dist[i], INF);
        }

        for (int i = 0; i < totalPoints; i++) {
            int[][] d = bfs(grid, points.get(i)[0], points.get(i)[1]);
            for (int j = 0; j < totalPoints; j++) {
                int x = points.get(j)[0], y = points.get(j)[1];
                if (d[x][y] != -1) {
                    dist[i][j] = d[x][y];
                }
            }
        }

        // Check if any turtle is unreachable
        for (int i = 1; i < totalPoints; i++) {
            if (dist[0][i] == INF) return -1;
        }

        // DP over subsets (bitmask)
        int maxMask = 1 << totalPoints;
        int[][] dp = new int[maxMask][totalPoints];
        for (int[] row : dp) Arrays.fill(row, INF);

        dp[1][0] = 0; // visited start (bit 0 set)

        for (int mask = 1; mask < maxMask; mask++) {
            for (int i = 0; i < totalPoints; i++) {
                if (dp[mask][i] == INF) continue;

                for (int j = 1; j < totalPoints; j++) {
                    if ((mask & (1 << j)) == 0) {
                        int nextMask = mask | (1 << j);
                        dp[nextMask][j] = Math.min(dp[nextMask][j],
                                                   dp[mask][i] + dist[i][j]);
                    }
                }
            }
        }

        int allVisitedMask = (1 << totalPoints) - 1;
        int ans = INF;
        for (int i = 1; i < totalPoints; i++) {
            ans = Math.min(ans, dp[allVisitedMask][i]);
        }

        return ans == INF ? -1 : ans;
    }

    // BFS from (sx, sy) to get shortest distance to all cells
    private static int[][] bfs(char[][] grid, int sx, int sy) {
        int n = grid.length, m = grid[0].length;
        int[][] dist = new int[n][m];
        for (int[] row : dist) Arrays.fill(row, -1);

        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{sx, sy});
        dist[sx][sy] = 0;

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];
            for (int k = 0; k < 4; k++) {
                int nx = x + dx[k], ny = y + dy[k];
                if (nx >= 0 && nx < n && ny >= 0 && ny < m &&
                    grid[nx][ny] != '#' && dist[nx][ny] == -1) {
                    dist[nx][ny] = dist[x][y] + 1;
                    q.offer(new int[]{nx, ny});
                }
            }
        }
        return dist;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(), M = sc.nextInt();
        char[][] grid = new char[N][M];
        for (int i = 0; i < N; i++) {
            String line = sc.next();
            grid[i] = line.toCharArray();
        }
        int sx = sc.nextInt(), sy = sc.nextInt();
        System.out.println(rescueTurtles(grid, sx, sy));
    }
}
