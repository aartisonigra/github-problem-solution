Problem Statement
In the Library of Forbidden Constructs, there are N magical scrolls. Some scrolls contain knowledge so dangerous that they can only be read after reading one or more prerequisite scrolls.

Each scroll has zero or more dependencies. A scroll cannot be read unless all of its prerequisites have already been read.

Your task is to determine whether it is possible to read all the scrolls without violating any prerequisite conditions. If possible, print one valid reading order that satisfies all dependencies. If it is impossible (due to cyclic dependencies), print "IMPOSSIBLE".

Among all possible reading orders, you must output the lexicographically smallest valid order. This means scrolls with smaller IDs should appear earlier where possible.

Input Format
The first line contains two integers N and M — the number of scrolls and the number of dependency rules.

The next M lines each contain two integers A and B denoting that scroll A must be read before scroll B.

Output Format
If a valid reading order exists, print N space-separated integers representing the lexicographically smallest order of reading the scrolls.

If no valid order exists due to a cycle, print a single line: IMPOSSIBLE

Constraints
1 ≤ N ≤ 10^5

0 ≤ M ≤ 2 × 10^5

1 ≤ A, B ≤ N

Sample Testcase 0
Testcase Input
4 4
1 2
2 3
3 4
4 2
Testcase Output
IMPOSSIBLE
Explanation
Scroll 2 depends on 1, scroll 3 on 2, scroll 4 on 3, and scroll 2 again on 4, forming a cycle.
 Hence, no valid reading order exists.

Sample Testcase 1
Testcase Input
6 6
1 3
2 3
3 4
4 5
4 6
2 5
Testcase Output
1 2 3 4 5 6
Explanation
Scroll 3 depends on both 1 and 2, so it must appear after them.
 Scroll 4 depends on 3, so it must come later.
 Scrolls 5 and 6 depend on 4 and 2, respectively.
 The lexicographically smallest valid order satisfying all constraints is:
 1 → 2 → 3 → 4 → 5 → 6


SOLUTIONS:

import java.util.*;

public class Main {

    public static List<Integer> findReadingOrder(int n, List<int[]> edges) {
        List<Integer> order = new ArrayList<>();
        List<Set<Integer>> graph = new ArrayList<>();
        int[] inDegree = new int[n + 1];

        // Initialize graph with sets to avoid duplicate edges
        for (int i = 0; i <= n; i++) {
            graph.add(new HashSet<>());
        }

        // Build graph and in-degree
        for (int[] edge : edges) {
            int from = edge[0];
            int to = edge[1];

            // Only add if edge not already present (avoid duplicates)
            if (graph.get(from).add(to)) {
                inDegree[to]++;
            }
        }

        // Min-Heap for lexicographical order
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        // Add nodes with in-degree 0
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                minHeap.add(i);
            }
        }

        while (!minHeap.isEmpty()) {
            int current = minHeap.poll();
            order.add(current);

            for (int neighbor : graph.get(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    minHeap.add(neighbor);
                }
            }
        }

        if (order.size() == n) {
            return order;
        } else {
            return new ArrayList<>();  // Indicate IMPOSSIBLE by returning empty list
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();
        List<int[]> edges = new ArrayList<>();

        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            edges.add(new int[]{a, b});
        }

        List<Integer> result = findReadingOrder(n, edges);

        if (result.isEmpty()) {
            System.out.println("IMPOSSIBLE");
        } else {
            for (int num : result) {
                System.out.print(num + " ");
            }
            System.out.println();
        }
    }
}
